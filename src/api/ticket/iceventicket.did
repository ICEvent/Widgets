type iceventicket = 
 service {
   acceptCycles: () -> ();
   addModerator: (principal) -> ();
   allowance: (AllowanceRequest) -> (Result_1) query;
   approve: (ApproveRequest) -> ();
   availableCycles: () -> (nat) query;
   balance: (BalanceRequest) -> (BalanceResponse) query;
   bearer: (TokenIdentifier__1) -> (Result_5) query;
   extensions: () -> (vec Extension) query;
   getAdmin: () -> (principal) query;
   getAllowances: () -> (vec record {
                               TokenIndex;
                               principal;
                             }) query;
   getMinters: () -> (vec Minter) query;
   getModerators: () -> (vec principal) query;
   getMyTickets: () -> (vec record {
                              TokenIdentifier__1;
                              Metadata__1;
                            }) query;
   getRegistry: () -> (vec record {
                             TokenIndex;
                             AccountIdentifier__1;
                           }) query;
   getTokenIdentifier: (TokenIndex) -> (TokenIdentifier__1) query;
   getTokens: () -> (vec record {
                           TokenIndex;
                           Metadata__1;
                         }) query;
   http_request: (Request) -> (Response) query;
   metadata: (TokenIdentifier__1) -> (Result_4) query;
   mintEventTickets: (MintTicketRequest) -> (Result_3);
   setAdmin: (principal) -> ();
   setDefaultAsset: (opt blob) -> ();
   setMinter: (principal, nat) -> (Result_2);
   supply: (TokenIdentifier__1) -> (Result_1) query;
   transactions: (TransactionsRequest) -> (Result) query;
   transfer: (TransferRequest) -> (TransferResponse);
   transferTicketWithId: (principal, TokenIdentifier__1) ->
    (TransferResponse);
   transferTicketWithIndex: (principal, TokenIndex) -> (TransferResponse);
 };
type User = 
 variant {
   address: AccountIdentifier;
   "principal": principal;
 };
type TransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: AccountIdentifier;
      InsufficientBalance;
      InvalidToken: TokenIdentifier;
      Other: text;
      Rejected;
      Unauthorized: AccountIdentifier;
    };
   ok: Balance;
 };
type TransferRequest__1 = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier;
 };
type TransferRequest = 
 record {
   amount: Balance;
   from: User;
   memo: Memo;
   notify: bool;
   subaccount: opt SubAccount;
   to: User;
   token: TokenIdentifier;
 };
type TransactionsRequest = 
 record {
   query_option:
    variant {
      all;
      date: record {
              Date;
              Date;
            };
      page: record {
              nat;
              nat;
            };
      txid: TransactionId;
      user: User;
    };
   token: TokenIdentifier;
 };
type TransactionId = nat;
type Transaction = 
 record {
   date: Date;
   request: TransferRequest__1;
   txid: TransactionId;
 };
type TokenIndex = nat32;
type TokenIdentifier__1 = text;
type TokenIdentifier = text;
type SubAccount = vec nat8;
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: StreamingCallback;
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StreamingCallback = func (StreamingCallbackToken) ->
                          (StreamingCallbackResponse) query;
type Result_5 = 
 variant {
   err: CommonError__1;
   ok: AccountIdentifier__1;
 };
type Result_4 = 
 variant {
   err: CommonError__1;
   ok: Metadata__1;
 };
type Result_3 = 
 variant {
   err: text;
   ok: vec TokenIndex;
 };
type Result_2 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_1 = 
 variant {
   err: CommonError__1;
   ok: Balance__1;
 };
type Result = 
 variant {
   err: CommonError;
   ok: vec Transaction;
 };
type Response = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type Request = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type Minter = 
 record {
   minted: vec TokenIndex;
   minter: principal;
   quota: nat;
 };
type MintTicketRequest = 
 record {
   metadatas: vec Metadata;
   spender: principal;
 };
type Metadata__1 = 
 record {
   asset: opt text;
   event_day: text;
   event_id: nat;
   event_location: text;
   event_name: text;
   host: text;
 };
type Metadata = 
 record {
   asset: opt text;
   event_day: text;
   event_id: nat;
   event_location: text;
   event_name: text;
   host: text;
 };
type Memo = blob;
type HeaderField = 
 record {
   text;
   text;
 };
type Extension = text;
type Date = nat64;
type CommonError__1 = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type CommonError = 
 variant {
   InvalidToken: TokenIdentifier;
   Other: text;
 };
type Balance__1 = nat;
type BalanceResponse = 
 variant {
   err: CommonError;
   ok: Balance;
 };
type BalanceRequest = 
 record {
   token: TokenIdentifier;
   user: User;
 };
type Balance = nat;
type ApproveRequest = 
 record {
   allowance: Balance;
   spender: principal;
   subaccount: opt SubAccount;
   token: TokenIdentifier;
 };
type AllowanceRequest = 
 record {
   owner: User;
   spender: principal;
   token: TokenIdentifier;
 };
type AccountIdentifier__1 = text;
type AccountIdentifier = text;
service : () -> iceventicket
